<!DOCTYPE html>
<html lang="zh-TW" data-lang="dual">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ’“ rPPG å¿ƒç‡ç›£æ¸¬å™¨ Pro â€” Heart Rate & HRV Monitor</title>
    <meta name="description" content="ä½¿ç”¨æ”å½±æ©Ÿå³æ™‚åµæ¸¬å¿ƒç‡ã€HRVã€è¡€æ°§ã€å‘¼å¸ç‡çš„ rPPG å°ˆæ¥­ç›£æ¸¬å·¥å…·">
    <!-- PWA -->
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#ff2d55">
    <!-- iOS PWA -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="rPPG Pro">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <!-- Favicon -->
    <link rel="icon" type="image/png" sizes="192x192" href="/icon-192.png">
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600&display=swap"
        rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/face_detection.js"
        crossorigin="anonymous"></script>
    <script src="signal.js"></script>
    <script src="analysis.js"></script>
    <script src="history.js"></script>
    <style>
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-card: #1a1a2e;
            --accent-primary: #ff2d55;
            --accent-secondary: #5856d6;
            --accent-tertiary: #30d158;
            --accent-warning: #ff9f0a;
            --accent-cyan: #5ac8fa;
            --text-primary: #f5f5f7;
            --text-secondary: #8e8e93;
            --text-tertiary: #636366;
            --border-color: rgba(255, 255, 255, 0.08);
            --glow-red: rgba(255, 45, 85, 0.3);
            --glow-purple: rgba(88, 86, 214, 0.3);
            --glow-green: rgba(48, 209, 88, 0.3);
        }

        [data-theme="light"] {
            --bg-primary: #f2f2f7;
            --bg-secondary: #ffffff;
            --bg-card: #ffffff;
            --text-primary: #1c1c1e;
            --text-secondary: #636366;
            --text-tertiary: #aeaeb2;
            --border-color: rgba(0, 0, 0, 0.08);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            transition: background 0.3s, color 0.3s;
        }

        .bg-anim {
            position: fixed;
            inset: 0;
            z-index: 0;
            pointer-events: none;
        }

        .bg-anim::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(ellipse at 30% 20%, rgba(255, 45, 85, 0.04)0%, transparent 50%), radial-gradient(ellipse at 70% 80%, rgba(88, 86, 214, 0.04)0%, transparent 50%);
            animation: bgP 8s ease-in-out infinite alternate;
        }

        @keyframes bgP {
            0% {
                transform: rotate(0) scale(1)
            }

            100% {
                transform: rotate(3deg) scale(1.05)
            }
        }

        [data-theme="light"] .bg-anim::before {
            opacity: 0.3;
        }

        .app {
            position: relative;
            z-index: 1;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .header-left h1 {
            font-size: 1.8rem;
            font-weight: 800;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header-left p {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        .header-right {
            display: flex;
            gap: 8px;
        }

        .icon-btn {
            width: 40px;
            height: 40px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            background: var(--bg-card);
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem;
            transition: all 0.2s;
        }

        .icon-btn:hover {
            transform: translateY(-2px);
            border-color: var(--accent-secondary);
        }

        .reorder-btns {
            display: flex;
            gap: 2px;
        }

        .reorder-btns button {
            width: 22px;
            height: 22px;
            border-radius: 5px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.55rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            padding: 0;
        }

        .reorder-btns button:hover {
            background: rgba(255, 149, 0, 0.2);
            color: #ff9500;
            border-color: rgba(255, 149, 0, 0.4);
        }

        .cam-select:focus {
            outline: none;
            border-color: var(--accent-secondary);
        }

        .threshold-wrap {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .threshold-wrap label {
            white-space: nowrap;
        }

        .threshold-wrap input[type=range] {
            flex: 1;
            accent-color: var(--accent-secondary);
            height: 4px;
            cursor: pointer;
        }

        .threshold-wrap .val {
            min-width: 32px;
            text-align: right;
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent-secondary);
            font-weight: 600;
        }

        .card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 16px;
            position: relative;
            transition: background 0.3s;
        }

        .card-title {
            font-size: 0.72rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-secondary);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        /* Layout */
        .grid-main {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 16px;
        }

        .grid-metrics {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 12px;
        }

        .grid-bottom {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 10px;
        }

        /* Video */
        .video-wrap {
            border-radius: 12px;
            overflow: hidden;
            background: #000;
            aspect-ratio: 4/3;
            position: relative;
        }

        #webcam {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            display: block;
        }

        #faceCanvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }

        .vid-overlay {
            position: absolute;
            top: 8px;
            left: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            padding: 4px 10px;
            border-radius: 16px;
            font-size: 0.7rem;
        }

        .rec-dot {
            width: 7px;
            height: 7px;
            background: var(--accent-primary);
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1
            }

            50% {
                opacity: 0.3
            }
        }

        .vid-placeholder {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            background: linear-gradient(135deg, var(--bg-secondary), var(--bg-card));
        }

        .vid-placeholder .cam-icon {
            font-size: 2.5rem;
            opacity: 0.4;
        }

        .vid-placeholder p {
            color: var(--text-secondary);
            font-size: 0.82rem;
        }

        /* Metric card */
        .m-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 14px;
            text-align: center;
            transition: all 0.3s;
        }

        .m-card .m-label {
            font-size: 0.62rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .m-card .m-val {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.8rem;
            font-weight: 700;
            line-height: 1;
            margin-bottom: 2px;
        }

        .m-card .m-ref {
            font-size: 0.58rem;
            color: var(--text-tertiary);
            margin-top: 4px;
            opacity: 0.7;
        }

        .m-card .m-unit {
            font-size: 0.65rem;
            color: var(--text-tertiary);
        }

        .m-card.hr .m-val {
            color: var(--accent-primary);
            text-shadow: 0 0 20px var(--glow-red);
        }

        .m-card.hrv .m-val {
            color: var(--accent-secondary);
            text-shadow: 0 0 20px var(--glow-purple);
        }

        .m-card.quality .m-val {
            color: var(--accent-tertiary);
        }

        .m-card.spo2 .m-val {
            color: var(--accent-cyan);
        }

        .m-card.breath .m-val {
            color: #66d4cf;
        }

        .m-card.emotion .m-val {
            font-size: 1.4rem;
        }

        /* Charts */
        .chart-wrap {
            height: 150px;
            position: relative;
        }

        .chart-wrap canvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }

        .trend-wrap {
            height: 120px;
            position: relative;
        }

        .trend-wrap canvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }

        /* Buttons */
        .btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 12px;
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn.start {
            background: linear-gradient(135deg, var(--accent-primary), #ff6b81);
            color: #fff;
            box-shadow: 0 4px 16px var(--glow-red);
        }

        .btn.stop {
            background: linear-gradient(135deg, var(--accent-secondary), #7b7be8);
            color: #fff;
        }

        .btn:hover {
            transform: translateY(-1px);
        }

        .btn-sm {
            padding: 8px 14px;
            font-size: 0.75rem;
            border-radius: 10px;
            width: auto;
        }

        .status-bar {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 8px;
            border-radius: 10px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            margin-top: 10px;
            font-size: 0.78rem;
            color: var(--text-secondary);
        }

        .status-dot {
            width: 7px;
            height: 7px;
            border-radius: 50%;
            background: var(--text-tertiary);
        }

        .status-bar.active .status-dot {
            background: var(--accent-tertiary);
            animation: pulse 1.5s infinite;
        }

        .status-bar.calibrating .status-dot {
            background: var(--accent-warning);
            animation: pulse 0.8s infinite;
        }

        .cal-bar {
            width: 100%;
            height: 3px;
            background: var(--bg-secondary);
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .cal-bar.vis {
            opacity: 1;
        }

        .cal-bar .fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            border-radius: 2px;
            transition: width 0.3s;
            width: 0%;
        }

        /* Bottom stats */
        .s-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 10px;
            text-align: center;
        }

        .s-card .s-label {
            font-size: 0.6rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-tertiary);
            margin-bottom: 3px;
        }

        .s-card .s-val {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            font-weight: 600;
        }

        /* HRV detail panel */
        .hrv-detail {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .hrv-item {
            text-align: center;
            padding: 8px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .hrv-item .hrv-label {
            font-size: 0.58rem;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-tertiary);
            margin-bottom: 2px;
        }

        .hrv-item .hrv-ref {
            font-size: 0.52rem;
            color: var(--text-tertiary);
            margin-top: 3px;
            opacity: 0.7;
        }

        .hrv-item .hrv-val {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            font-weight: 600;
            color: var(--accent-secondary);
        }

        .heartbeat-icon {
            display: inline-block;
            font-size: 1rem;
        }

        .heartbeat-icon.beating {
            animation: hb 1s infinite;
        }

        @keyframes hb {

            0%,
            100% {
                transform: scale(1)
            }

            15% {
                transform: scale(1.3)
            }

            30% {
                transform: scale(1)
            }

            45% {
                transform: scale(1.2)
            }
        }

        /* Multi-person badge */
        .person-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            border-radius: 8px;
            font-size: 0.65rem;
            font-weight: 600;
            background: rgba(88, 86, 214, 0.15);
            color: var(--accent-secondary);
        }

        @media(max-width:900px) {
            .grid-main {
                grid-template-columns: 1fr;
            }

            .grid-metrics {
                grid-template-columns: repeat(2, 1fr);
            }

            .grid-bottom {
                grid-template-columns: repeat(3, 1fr);
            }

            .hrv-detail {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media(max-width:500px) {
            .app {
                padding: 8px;
            }

            .header h1 {
                font-size: 1rem;
            }

            .header p {
                font-size: 0.55rem;
            }

            .card {
                padding: 10px;
            }

            .card-title {
                font-size: 0.7rem;
            }

            .metric {
                padding: 6px;
            }

            .metric .value {
                font-size: 1.2rem;
            }

            .metric .label {
                font-size: 0.5rem;
            }

            .grid-metrics {
                grid-template-columns: repeat(2, 1fr);
                gap: 6px;
            }

            .grid-bottom {
                grid-template-columns: repeat(2, 1fr);
                gap: 6px;
            }

            .grid-bottom .stat-box {
                padding: 8px 4px;
            }

            .grid-bottom .stat-box .value {
                font-size: 0.9rem;
            }

            .grid-bottom .stat-box .label {
                font-size: 0.5rem;
            }

            .hrv-detail {
                grid-template-columns: repeat(2, 1fr);
                gap: 4px;
            }

            .cam-select {
                font-size: 0.65rem;
                padding: 6px;
            }

            .btn {
                padding: 10px;
                font-size: 0.75rem;
            }

            .threshold-wrap {
                font-size: 0.65rem;
            }

            #harmonicDetail {
                grid-template-columns: repeat(3, 1fr) !important;
                gap: 4px !important;
            }

            .icon-btn {
                width: 32px;
                height: 32px;
                font-size: 0.85rem;
            }
        }
    </style>
</head>

<body>
    <div class="bg-anim"></div>
    <div class="app">
        <div class="header">
            <div class="header-left">
                <h1><span class="heartbeat-icon" id="heartIcon">ğŸ’“</span> rPPG Pro <span data-i18n="å¿ƒç‡ç›£æ¸¬å™¨">å¿ƒç‡ç›£æ¸¬å™¨</span>
                </h1>
                <p><span data-i18n="POS+CHROM èåˆ Â· Welch FFT Â· å¤šå€åŸŸ ROI Â· å“è³ªé–€æ§">POS+CHROM èåˆ Â· Welch FFT Â· å¤šå€åŸŸ ROI Â·
                        å“è³ªé–€æ§</span></p>
            </div>
            <div class="header-right">
                <button class="icon-btn" onclick="toggleLang()" title="Language / èªè¨€" id="langBtn">ğŸŒ</button>
                <button class="icon-btn" onclick="toggleTheme()" title="åˆ‡æ›ä¸»é¡Œ" id="themeBtn">ğŸŒ™</button>
                <button class="icon-btn" onclick="toggleSound()" title="å¿ƒè·³éŸ³æ•ˆ" id="soundBtn">ğŸ”‡</button>
                <button class="icon-btn" onclick="exportReport()" title="åŒ¯å‡ºå ±å‘Š">ğŸ“„</button>
            </div>
        </div>

        <!-- User Account Bar -->
        <div
            style="display:flex;align-items:center;gap:8px;padding:8px 12px;background:var(--bg-secondary);border-radius:10px;margin-bottom:12px;border:1px solid var(--border-color)">
            <span style="font-size:0.75rem;color:var(--text-secondary)">ğŸ‘¤ <span data-i18n="ä½¿ç”¨è€…">ä½¿ç”¨è€…</span></span>
            <select id="userSelect" onchange="switchUser(this.value)"
                style="flex:1;background:var(--bg-primary);color:var(--text-primary);border:1px solid var(--border-color);border-radius:6px;padding:5px 8px;font-size:0.7rem;font-family:inherit">
                <option value="default" data-i18n="è¨ªå®¢">è¨ªå®¢</option>
            </select>
            <button onclick="toggleAddUser()" id="addUserBtn"
                style="background:rgba(52,199,89,0.2);color:#34c759;border:1px solid rgba(52,199,89,0.3);padding:4px 10px;border-radius:6px;font-size:0.65rem;cursor:pointer;white-space:nowrap">
                ï¼‹ <span data-i18n="æ–°å¢">æ–°å¢</span>
            </button>
            <div id="addUserInput" style="display:none;display:none;align-items:center;gap:4px">
                <input type="text" id="newUserName" placeholder="è¼¸å…¥åç¨±" data-i18n-placeholder="è¼¸å…¥åç¨±"
                    style="width:80px;background:var(--bg-primary);color:var(--text-primary);border:1px solid var(--border-color);border-radius:6px;padding:4px 6px;font-size:0.65rem;font-family:inherit"
                    onkeydown="if(event.key==='Enter')confirmAddUser()">
                <button onclick="confirmAddUser()"
                    style="background:rgba(52,199,89,0.3);color:#34c759;border:1px solid rgba(52,199,89,0.4);padding:4px 8px;border-radius:6px;font-size:0.6rem;cursor:pointer">âœ“</button>
                <button onclick="toggleAddUser()"
                    style="background:rgba(255,45,85,0.15);color:#ff2d55;border:1px solid rgba(255,45,85,0.3);padding:4px 6px;border-radius:6px;font-size:0.6rem;cursor:pointer">âœ•</button>
            </div>
        </div>

        <div class="grid-main">
            <!-- Left: Video -->
            <div class="card">
                <div class="card-title">ğŸ“¹ <span data-i18n="å³æ™‚å½±åƒ">å³æ™‚å½±åƒ</span> <span class="person-badge"
                        id="personBadge" style="display:none">ğŸ‘¤
                        <span id="personCount">1</span> <span data-i18n="äºº">äºº</span></span></div>
                <div class="video-wrap" id="videoWrap">
                    <video id="webcam" autoplay playsinline muted></video>
                    <canvas id="faceCanvas"></canvas>
                    <div class="vid-overlay" id="vidOverlay" style="display:none">
                        <div class="rec-dot"></div><span data-i18n="åµæ¸¬ä¸­">åµæ¸¬ä¸­</span>
                    </div>
                    <div class="vid-placeholder" id="vidPlaceholder">
                        <div class="cam-icon">ğŸ“·</div>
                        <p data-i18n="é»æ“Šä¸‹æ–¹æŒ‰éˆ•é–‹å•Ÿæ”å½±æ©Ÿ">é»æ“Šä¸‹æ–¹æŒ‰éˆ•é–‹å•Ÿæ”å½±æ©Ÿ</p>
                    </div>
                </div>
                <div class="cal-bar" id="calBar">
                    <div class="fill" id="calFill"></div>
                </div>
                <div class="status-bar" id="statusBar">
                    <div class="status-dot"></div><span id="statusText" data-i18n="ç­‰å¾…å•Ÿå‹•...">ç­‰å¾…å•Ÿå‹•...</span>
                </div>
                <select class="cam-select" id="camSelect">
                    <option value="" data-i18n="é¸æ“‡é¡é ­ï¼ˆé è¨­ï¼‰">ğŸ“· é¸æ“‡é¡é ­ï¼ˆé è¨­ï¼‰</option>
                </select>
                <div class="threshold-wrap">
                    <label>ğŸ”’ <span data-i18n="å“è³ªé–€æª»">å“è³ªé–€æª»</span></label>
                    <input type="range" id="qualThreshold" min="10" max="95" value="70"
                        oninput="document.getElementById('threshVal').textContent=this.value+'%'">
                    <span class="val" id="threshVal">70%</span>
                </div>
                <button class="btn start" id="startBtn" onclick="toggleMonitoring()">ğŸš€ <span
                        data-i18n="é–‹å§‹åµæ¸¬">é–‹å§‹åµæ¸¬</span></button>
            </div>

            <!-- Right: Sortable Sections -->
            <div id="sortableContainer" style="display:flex;flex-direction:column;gap:16px;">
                <div class="sortable-section" data-section="metrics">
                    <div class="card">
                        <div class="card-title" style="display:flex;justify-content:space-between;align-items:center">
                            <span>ğŸ“Š <span data-i18n="å³æ™‚æ•¸æ“š">å³æ™‚æ•¸æ“š</span></span>
                            <div class="reorder-btns">
                                <button onclick="moveSection(this,-1)" title="ä¸Šç§» / Move Up">â–²</button>
                                <button onclick="moveSection(this,1)" title="ä¸‹ç§» / Move Down">â–¼</button>
                            </div>
                        </div>
                        <div class="grid-metrics">
                            <div class="m-card hr">
                                <div class="m-label" data-i18n="å¿ƒç‡">å¿ƒç‡</div>
                                <div class="m-val" id="hrVal">--</div>
                                <div class="m-unit">BPM</div>
                                <div class="m-ref" data-i18n="æ­£å¸¸ 60-100">æ­£å¸¸ 60-100</div>
                            </div>
                            <div class="m-card hrv">
                                <div class="m-label">HRV (SDNN)</div>
                                <div class="m-val" id="hrvVal">--</div>
                                <div class="m-unit">ms</div>
                                <div class="m-ref" data-i18n="æ­£å¸¸ 50-100">æ­£å¸¸ 50-100</div>
                            </div>
                            <div class="m-card quality">
                                <div class="m-label" data-i18n="è¨Šè™Ÿå“è³ª">è¨Šè™Ÿå“è³ª</div>
                                <div class="m-val" id="qualVal">--</div>
                                <div class="m-unit">%</div>
                                <div class="m-ref" data-i18n="è‰¯å¥½ >70%">è‰¯å¥½ >70%</div>
                            </div>
                            <div class="m-card spo2">
                                <div class="m-label" data-i18n="è¡€æ°§ SpO2">è¡€æ°§ SpO2</div>
                                <div class="m-val" id="spo2Val">--</div>
                                <div class="m-unit">%</div>
                                <div class="m-ref" data-i18n="æ­£å¸¸ 95-100">æ­£å¸¸ 95-100</div>
                            </div>
                            <div class="m-card breath">
                                <div class="m-label" data-i18n="å‘¼å¸é »ç‡">å‘¼å¸é »ç‡</div>
                                <div class="m-val" id="breathVal">--</div>
                                <div class="m-unit" data-i18n="æ¬¡/åˆ†">æ¬¡/åˆ†</div>
                                <div class="m-ref" data-i18n="æ­£å¸¸ 12-20">æ­£å¸¸ 12-20</div>
                            </div>
                            <div class="m-card emotion">
                                <div class="m-label" data-i18n="æƒ…ç·’ç‹€æ…‹">æƒ…ç·’ç‹€æ…‹</div>
                                <div class="m-val" id="emotionVal">--</div>
                                <div class="m-unit" id="emotionLabel"></div>
                                <div class="m-ref" data-i18n="ğŸ˜Šæ”¾é¬† â†’ ğŸ˜°ç·Šå¼µ">ğŸ˜Šæ”¾é¬† â†’ ğŸ˜°ç·Šå¼µ</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="sortable-section" data-section="hrv">
                    <div class="card">
                        <div class="card-title" style="display:flex;justify-content:space-between;align-items:center">
                            <span>ğŸ’œ <span data-i18n="HRV è©³ç´°æŒ‡æ¨™">HRV è©³ç´°æŒ‡æ¨™</span></span>
                            <div class="reorder-btns">
                                <button onclick="moveSection(this,-1)" title="ä¸Šç§»">â–²</button>
                                <button onclick="moveSection(this,1)" title="ä¸‹ç§»">â–¼</button>
                            </div>
                        </div>
                        <div class="hrv-detail">
                            <div class="hrv-item">
                                <div class="hrv-label">RMSSD</div>
                                <div class="hrv-val" id="rmssdVal">--</div>
                                <div class="hrv-ref" data-i18n="æ­£å¸¸ 20-50ms">æ­£å¸¸ 20-50ms</div>
                            </div>
                            <div class="hrv-item">
                                <div class="hrv-label">pNN50</div>
                                <div class="hrv-val" id="pnn50Val">--%</div>
                                <div class="hrv-ref" data-i18n="æ­£å¸¸ >3%">æ­£å¸¸ >3%</div>
                            </div>
                            <div class="hrv-item">
                                <div class="hrv-label">LF/HF</div>
                                <div class="hrv-val" id="lfhfVal">--</div>
                                <div class="hrv-ref" data-i18n="å¹³è¡¡ 0.5-2.0">å¹³è¡¡ 0.5-2.0</div>
                            </div>
                            <div class="hrv-item">
                                <div class="hrv-label">Mean RR</div>
                                <div class="hrv-val" id="meanRRVal">--ms</div>
                                <div class="hrv-ref" data-i18n="æ­£å¸¸ 600-1000ms">æ­£å¸¸ 600-1000ms</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="sortable-section" data-section="signal">
                    <div class="card">
                        <div class="card-title" style="display:flex;justify-content:space-between;align-items:center">
                            <span>ã€°ï¸ <span data-i18n="PPG è¨Šè™Ÿ">PPG è¨Šè™Ÿ</span> (POS+CHROM Fusion)</span>
                            <div class="reorder-btns">
                                <button onclick="moveSection(this,-1)" title="ä¸Šç§»">â–²</button>
                                <button onclick="moveSection(this,1)" title="ä¸‹ç§»">â–¼</button>
                            </div>
                        </div>
                        <div class="chart-wrap"><canvas id="signalCanvas"></canvas></div>
                    </div>
                </div>

                <div class="sortable-section" data-section="trend">
                    <div class="card">
                        <div class="card-title" style="display:flex;justify-content:space-between;align-items:center">
                            <span>ğŸ“ˆ <span data-i18n="å¿ƒç‡è¶¨å‹¢">å¿ƒç‡è¶¨å‹¢</span></span>
                            <div class="reorder-btns">
                                <button onclick="moveSection(this,-1)" title="ä¸Šç§»">â–²</button>
                                <button onclick="moveSection(this,1)" title="ä¸‹ç§»">â–¼</button>
                            </div>
                        </div>
                        <div class="trend-wrap"><canvas id="trendCanvas"></canvas></div>
                    </div>
                </div>

                <div class="sortable-section" data-section="harmonics">
                    <div class="card">
                        <div class="card-title" style="display:flex;justify-content:space-between;align-items:center">
                            <span>â˜¯ï¸ <span data-i18n="è„ˆè¨ºåˆ†æï¼ˆç‹å”¯å·¥è«§æ³¢ï¼‰">è„ˆè¨ºåˆ†æï¼ˆç‹å”¯å·¥è«§æ³¢ï¼‰</span><span id="constitutionBadge"
                                    style="font-size:0.75rem;opacity:0.8;margin-left:8px"></span></span>
                            <div class="reorder-btns">
                                <button onclick="moveSection(this,-1)" title="ä¸Šç§»">â–²</button>
                                <button onclick="moveSection(this,1)" title="ä¸‹ç§»">â–¼</button>
                            </div>
                        </div>
                        <div class="chart-wrap"><canvas id="harmonicCanvas"></canvas></div>
                        <div id="harmonicDetail"
                            style="display:grid;grid-template-columns:repeat(auto-fill,minmax(80px,1fr));gap:6px;margin-top:10px;font-size:0.65rem;">
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Bottom Stats -->
        <div class="grid-bottom">
            <div class="s-card">
                <div class="s-label" data-i18n="æ¸¬é‡æ™‚é•·">æ¸¬é‡æ™‚é•·</div>
                <div class="s-val" id="duration">00:00</div>
            </div>
            <div class="s-card">
                <div class="s-label" data-i18n="å¹³å‡å¿ƒç‡">å¹³å‡å¿ƒç‡</div>
                <div class="s-val" id="avgHR">--</div>
            </div>
            <div class="s-card">
                <div class="s-label" data-i18n="æœ€é«˜å¿ƒç‡">æœ€é«˜å¿ƒç‡</div>
                <div class="s-val" id="maxHR">--</div>
            </div>
            <div class="s-card">
                <div class="s-label" data-i18n="æœ€ä½å¿ƒç‡">æœ€ä½å¿ƒç‡</div>
                <div class="s-val" id="minHR">--</div>
            </div>
            <div class="s-card">
                <div class="s-label" data-i18n="å¹³å‡è¡€æ°§">å¹³å‡è¡€æ°§</div>
                <div class="s-val" id="avgSpO2">--</div>
            </div>
            <div class="s-card">
                <div class="s-label" data-i18n="å¹³å‡å‘¼å¸ç‡">å¹³å‡å‘¼å¸ç‡</div>
                <div class="s-val" id="avgBreath">--</div>
            </div>
        </div>

        <!-- Stress Detection (Lie Detector) -->
        <div class="card" style="margin-top:16px" id="stressCard">
            <div class="card-title" style="display:flex;justify-content:space-between;align-items:center">
                <span>ğŸ” <span data-i18n="å£“åŠ›åµæ¸¬æ¨¡å¼">å£“åŠ›åµæ¸¬æ¨¡å¼</span></span>
                <div style="display:flex;gap:6px">
                    <button id="stressBtn" onclick="toggleStressMode()"
                        style="background:rgba(255,149,0,0.2);color:#ff9500;border:1px solid rgba(255,149,0,0.3);padding:4px 12px;border-radius:6px;font-size:0.65rem;cursor:pointer">
                        â–¶ï¸ <span data-i18n="å•Ÿå‹•">å•Ÿå‹•</span>
                    </button>
                </div>
            </div>
            <div id="stressPanel" style="display:none">
                <!-- Phase indicator -->
                <div id="stressPhase"
                    style="text-align:center;padding:8px;font-size:0.75rem;color:var(--text-secondary)"></div>
                <!-- Progress bar for baseline -->
                <div id="stressProgress" style="display:none;margin:6px 0">
                    <div style="background:rgba(255,255,255,0.08);border-radius:4px;height:6px;overflow:hidden">
                        <div id="stressProgressBar"
                            style="height:100%;width:0%;background:linear-gradient(90deg,#34c759,#30d158);border-radius:4px;transition:width 1s linear">
                        </div>
                    </div>
                </div>
                <!-- Stress gauge -->
                <div style="display:flex;align-items:center;gap:12px;margin:10px 0">
                    <div style="flex:1">
                        <div
                            style="display:flex;justify-content:space-between;font-size:0.55rem;color:var(--text-secondary);margin-bottom:2px">
                            <span>ğŸ˜Œ <span data-i18n="æ”¾é¬†">æ”¾é¬†</span></span><span>ğŸ˜° <span
                                    data-i18n="ç·Šå¼µ">ç·Šå¼µ</span></span><span>ğŸš¨ <span data-i18n="é«˜å£“">é«˜å£“</span></span>
                        </div>
                        <div
                            style="background:rgba(255,255,255,0.08);border-radius:6px;height:18px;overflow:hidden;position:relative">
                            <div id="stressGauge"
                                style="height:100%;width:0%;border-radius:6px;transition:width 0.5s,background 0.5s;background:linear-gradient(90deg,#34c759,#ff9500,#ff2d55)">
                            </div>
                        </div>
                    </div>
                    <div style="text-align:center;min-width:50px">
                        <div id="stressScore" style="font-size:1.4rem;font-weight:800;color:#34c759">0</div>
                        <div style="font-size:0.5rem;color:var(--text-secondary)" data-i18n="å£“åŠ›æŒ‡æ•¸">å£“åŠ›æŒ‡æ•¸</div>
                    </div>
                </div>
                <!-- Detail indicators -->
                <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px;margin-top:6px">
                    <div
                        style="text-align:center;padding:6px;background:rgba(255,45,85,0.08);border-radius:8px;border:1px solid rgba(255,45,85,0.15)">
                        <div style="font-size:0.55rem;color:var(--text-secondary)" data-i18n="å¿ƒç‡è®ŠåŒ–">ğŸ’“ å¿ƒç‡è®ŠåŒ–</div>
                        <div id="stressHR" style="font-size:0.9rem;font-weight:700;color:#ff2d55">--</div>
                    </div>
                    <div
                        style="text-align:center;padding:6px;background:rgba(88,86,214,0.08);border-radius:8px;border:1px solid rgba(88,86,214,0.15)">
                        <div style="font-size:0.55rem;color:var(--text-secondary)" data-i18n="HRV è®ŠåŒ–">ğŸ“Š HRV è®ŠåŒ–</div>
                        <div id="stressHRV" style="font-size:0.9rem;font-weight:700;color:var(--accent-secondary)">--
                        </div>
                    </div>
                    <div
                        style="text-align:center;padding:6px;background:rgba(52,199,89,0.08);border-radius:8px;border:1px solid rgba(52,199,89,0.15)">
                        <div style="font-size:0.55rem;color:var(--text-secondary)" data-i18n="å‘¼å¸è®ŠåŒ–">ğŸ« å‘¼å¸è®ŠåŒ–</div>
                        <div id="stressBreath" style="font-size:0.9rem;font-weight:700;color:#34c759">--</div>
                    </div>
                </div>
                <!-- Verdict -->
                <div id="stressVerdict"
                    style="text-align:center;padding:10px;margin-top:8px;font-size:0.8rem;font-weight:600;border-radius:8px;display:none">
                </div>
                <!-- Disclaimer -->
                <div style="text-align:center;font-size:0.5rem;color:var(--text-secondary);margin-top:6px;opacity:0.6">
                    <span data-i18n="åƒ…ä¾›å¨›æ¨‚åƒè€ƒï¼Œç·Šå¼µâ‰ èªªè¬Šï¼Œä¸å…·ä»»ä½•æ³•å¾‹æˆ–é†«å­¸æ•ˆåŠ›">âš ï¸ åƒ…ä¾›å¨›æ¨‚åƒè€ƒï¼Œç·Šå¼µâ‰ èªªè¬Šï¼Œä¸å…·ä»»ä½•æ³•å¾‹æˆ–é†«å­¸æ•ˆåŠ›</span>
                </div>
            </div>
        </div>

        <!-- History Records -->
        <div class="card" style="margin-top:16px">
            <div class="card-title" style="display:flex;justify-content:space-between;align-items:center">
                <span>ğŸ“‹ <span data-i18n="æ­·å²è¨˜éŒ„">æ­·å²è¨˜éŒ„</span></span>
                <div style="display:flex;gap:6px">
                    <button onclick="exportSessionsCSV()"
                        style="background:rgba(88,86,214,0.2);color:var(--accent-secondary);border:1px solid rgba(88,86,214,0.3);padding:3px 8px;border-radius:6px;font-size:0.6rem;cursor:pointer">ğŸ“¥
                        åŒ¯å‡º CSV</button>
                    <button onclick="if(confirm('ç¢ºå®šæ¸…é™¤æ‰€æœ‰è¨˜éŒ„ï¼Ÿ')){clearAllSessions().then(()=>loadHistoryUI())}"
                        style="background:rgba(255,45,85,0.15);color:#ff2d55;border:1px solid rgba(255,45,85,0.3);padding:3px 8px;border-radius:6px;font-size:0.6rem;cursor:pointer">ğŸ—‘ï¸
                        <span data-i18n="æ¸…é™¤">æ¸…é™¤</span></button>
                </div>
            </div>
            <div id="historyTable" style="overflow-x:auto;max-height:300px;overflow-y:auto">
                <div style="text-align:center;color:var(--text-secondary);padding:20px;font-size:0.75rem"
                    data-i18n="è¼‰å…¥ä¸­...">è¼‰å…¥ä¸­...</div>
            </div>
        </div>
    </div>

    <script>
        // ===== State =====
        let isRunning = false, stream = null, animFrameId = null, startTime = null;
        let samplingCanvas, samplingCtx, signalCanvas, signalCtx, faceCanvas, faceCtx, trendCanvas, trendCtx, harmonicCanvas, harmonicCtx;

        const BUF = 300;
        const gSig = [], rSig = [], bSig = [], ts = [];
        const hrHist = [], rrIntervals = [];
        let frameCount = 0, allHR = [], allSpO2 = [], allBreath = [], hrTrend = [];
        let durationInterval = null;

        // Face tracking
        let mpFace = null, hasFaceAPI = false, lastFaceBox = null, smoothBox = null;
        let allFaceBoxes = []; // multi-person
        const SM = 0.4;

        // Sound
        let audioCtx = null, soundEnabled = false;

        // Theme
        let darkMode = true;

        // ===== i18n Bilingual System =====
        let currentLang = localStorage.getItem('rppg-lang') || 'dual'; // zh, en, dual
        const I18N = {
            'å¿ƒç‡ç›£æ¸¬å™¨': 'Heart Rate Monitor',
            'POS+CHROM èåˆ Â· Welch FFT Â· å¤šå€åŸŸ ROI Â· å“è³ªé–€æ§': 'POS+CHROM Fusion Â· Welch FFT Â· Multi-ROI Â· Quality Gate',
            'ä½¿ç”¨è€…': 'User',
            'è¨ªå®¢': 'Guest',
            'æ–°å¢': 'Add',
            'è¼¸å…¥åç¨±': 'Enter name',
            'å³æ™‚å½±åƒ': 'Live Camera',
            'äºº': 'people',
            'åµæ¸¬ä¸­': 'Detecting',
            'é»æ“Šä¸‹æ–¹æŒ‰éˆ•é–‹å•Ÿæ”å½±æ©Ÿ': 'Click below to start camera',
            'ç­‰å¾…å•Ÿå‹•...': 'Waiting...',
            'é¸æ“‡é¡é ­ï¼ˆé è¨­ï¼‰': 'Select Camera (Default)',
            'å“è³ªé–€æª»': 'Quality Threshold',
            'é–‹å§‹åµæ¸¬': 'Start Detection',
            'åœæ­¢åµæ¸¬': 'Stop Detection',
            'å³æ™‚æ•¸æ“š': 'Live Metrics',
            'å¿ƒç‡': 'Heart Rate',
            'æ­£å¸¸ 60-100': 'Normal 60-100',
            'æ­£å¸¸ 50-100': 'Normal 50-100',
            'è¨Šè™Ÿå“è³ª': 'Signal Quality',
            'è‰¯å¥½ >70%': 'Good >70%',
            'è¡€æ°§ SpO2': 'SpOâ‚‚',
            'æ­£å¸¸ 95-100': 'Normal 95-100',
            'å‘¼å¸é »ç‡': 'Breath Rate',
            'æ¬¡/åˆ†': 'br/min',
            'æ­£å¸¸ 12-20': 'Normal 12-20',
            'æƒ…ç·’ç‹€æ…‹': 'Emotion',
            'ğŸ˜Šæ”¾é¬† â†’ ğŸ˜°ç·Šå¼µ': 'ğŸ˜ŠRelaxed â†’ ğŸ˜°Tense',
            'HRV è©³ç´°æŒ‡æ¨™': 'HRV Details',
            'æ­£å¸¸ 20-50ms': 'Normal 20-50ms',
            'æ­£å¸¸ >3%': 'Normal >3%',
            'å¹³è¡¡ 0.5-2.0': 'Balance 0.5-2.0',
            'æ­£å¸¸ 600-1000ms': 'Normal 600-1000ms',
            'PPG è¨Šè™Ÿ': 'PPG Signal',
            'å¿ƒç‡è¶¨å‹¢': 'HR Trend',
            'è„ˆè¨ºåˆ†æï¼ˆç‹å”¯å·¥è«§æ³¢ï¼‰': 'Pulse Analysis (Wang Harmonic)',
            'æ¸¬é‡æ™‚é•·': 'Duration',
            'å¹³å‡å¿ƒç‡': 'Avg HR',
            'æœ€é«˜å¿ƒç‡': 'Max HR',
            'æœ€ä½å¿ƒç‡': 'Min HR',
            'å¹³å‡è¡€æ°§': 'Avg SpOâ‚‚',
            'å¹³å‡å‘¼å¸ç‡': 'Avg Breath',
            'å£“åŠ›åµæ¸¬æ¨¡å¼': 'Stress Detection',
            'å•Ÿå‹•': 'Start',
            'åœæ­¢': 'Stop',
            'æ”¾é¬†': 'Relaxed',
            'ç·Šå¼µ': 'Tense',
            'é«˜å£“': 'High Stress',
            'å£“åŠ›æŒ‡æ•¸': 'Stress Index',
            'å¿ƒç‡è®ŠåŒ–': 'ğŸ’“ HR Change',
            'HRV è®ŠåŒ–': 'ğŸ“Š HRV Change',
            'å‘¼å¸è®ŠåŒ–': 'ğŸ« Breath Change',
            'åƒ…ä¾›å¨›æ¨‚åƒè€ƒï¼Œç·Šå¼µâ‰ èªªè¬Šï¼Œä¸å…·ä»»ä½•æ³•å¾‹æˆ–é†«å­¸æ•ˆåŠ›': 'âš ï¸ Entertainment only. Tension â‰  lying. No legal or medical validity.',
            'æ­·å²è¨˜éŒ„': 'History',
            'åŒ¯å‡º CSV': 'Export CSV',
            'æ¸…é™¤': 'Clear',
            'è¼‰å…¥ä¸­...': 'Loading...',
            // Dynamic JS strings
            'æ­£åœ¨å•Ÿå‹•æ”å½±æ©Ÿ...': 'Starting camera...',
            'ç„¡æ³•å­˜å–æ”å½±æ©Ÿ': 'Cannot access camera',
            'åµæ¸¬å·²åœæ­¢ï¼Œè¨˜éŒ„å·²å„²å­˜': 'Detection stopped, session saved',
            'åµæ¸¬å·²åœæ­¢ï¼ˆå¤ªçŸ­æœªå„²å­˜ï¼‰': 'Stopped (too short to save)',
            'æ ¡æº–ä¸­...': 'Calibrating...',
            'ğŸ¯ å¤šå€åŸŸ ROI è¿½è¹¤ä¸­': 'ğŸ¯ Multi-ROI Tracking',
            'æœªåµæ¸¬åˆ°è‡‰éƒ¨ï¼Œè«‹é¢å°é¡é ­': 'No face detected, please face camera',
            'âš ï¸ åµæ¸¬åˆ°ç§»å‹•ï¼Œè«‹ä¿æŒéœæ­¢': 'âš ï¸ Motion detected, stay still',
            'ğŸ“¡ è¨Šè™Ÿå“è³ªä¸è¶³ï¼Œè«‹èª¿æ•´å…‰ç·šæˆ–å§¿å‹¢': 'ğŸ“¡ Low signal, adjust light or posture',
            'è«‹å…ˆæ¸¬é‡æ•¸æ“šå†åŒ¯å‡ºå ±å‘Š': 'Please measure data before exporting',
            'è«‹å…ˆå•Ÿå‹•æ”å½±æ©Ÿåµæ¸¬ï¼': 'Please start camera detection first!',
            'ç­‰å¾…è¨Šè™Ÿ...': 'Waiting for signal...',
            'ç­‰å¾…è¶¨å‹¢æ•¸æ“š...': 'Waiting for trend data...',
            'ç­‰å¾…è„ˆè¨ºæ•¸æ“š...': 'Waiting for pulse data...',
            'å°šç„¡è¨˜éŒ„ã€‚é–‹å§‹åµæ¸¬ä¸¦åœæ­¢å¾Œæœƒè‡ªå‹•å„²å­˜ã€‚': 'No records yet. Start a session and stop to auto-save.',
            'æ—¥æœŸ': 'Date',
            'æ™‚é•·': 'Duration',
            'é«”è³ª': 'Constitution',
            'åˆªé™¤': 'Delete',
            'ç¢ºå®šæ¸…é™¤æ‰€æœ‰è¨˜éŒ„ï¼Ÿ': 'Clear all records?',
            'ğŸ˜Œ éå¸¸æ”¾é¬† â€” æœªåµæ¸¬åˆ°å£“åŠ›åæ‡‰': 'ğŸ˜Œ Very relaxed â€” no stress detected',
            'ğŸ™‚ è¼•å¾®æ³¢å‹• â€” æ­£å¸¸ç¯„åœå…§': 'ğŸ™‚ Minor fluctuation â€” within normal range',
            'ğŸ˜ ä¸­ç­‰å£“åŠ› â€” åµæ¸¬åˆ°ç”Ÿç†åæ‡‰': 'ğŸ˜ Moderate stress â€” physiological response detected',
            'ğŸ˜° æ˜é¡¯å£“åŠ› â€” å¤šé …æŒ‡æ¨™ç•°å¸¸': 'ğŸ˜° Significant stress â€” multiple indicators abnormal',
            'ğŸš¨ é«˜åº¦ç·Šå¼µ â€” å¼·çƒˆç”Ÿç†å£“åŠ›åæ‡‰': 'ğŸš¨ High tension â€” strong stress response',
            'è«‹ä¿æŒæ”¾é¬†ï¼Œæ­£å¸¸å‘¼å¸ 30 ç§’...': 'Stay relaxed, breathe normally for 30s...',
            'å‘¼å¸': 'Breath',
            'æ¬¡/åˆ†': 'br/min',
            'é¡é ­': 'Camera',
            // Organ names (pulse analysis)
            'å¿ƒ': 'Heart', 'è‚': 'Liver', 'è…': 'Kidney', 'è„¾': 'Spleen',
            'è‚º': 'Lung', 'èƒƒ': 'Stomach', 'è†½': 'Gallbladder', 'è†€èƒ±': 'Bladder',
            'å¤§è…¸': 'L. Intestine', 'ä¸‰ç„¦': 'Triple Burner', 'å°è…¸': 'S. Intestine',
            // Organ statuses
            'åäº¢': 'Hyperactive', 'æ­£å¸¸': 'Normal', 'åå¼±': 'Weak',
            'ä¸è¶³': 'Deficient', 'åé«˜': 'Elevated',
            // Constitution assessments
            'å¿ƒè„¾å…©è™›ï¼ˆæ³¨æ„å¿ƒè¡€ç®¡ï¼‰': 'Heart-Spleen Deficiency (Watch Cardiovascular)',
            'è‚æ°£åæ—º': 'Liver Qi Excess',
            'è…æ°£ä¸è¶³': 'Kidney Qi Deficiency',
            'è„¾æ°£è™›å¼±': 'Spleen Qi Deficiency',
            'è‚ºæ°£ä¸è¶³': 'Lung Qi Deficiency',
            'æ°£è¡€å¹³è¡¡': 'Balanced Qi & Blood',
            'ç•¥æœ‰åå·®': 'Slight Imbalance',
            // Emotion states
            'é«˜åº¦ç·Šå¼µ': 'High Tension',
            'ç·Šå¼µ': 'Tense',
            'ä¸€èˆ¬': 'Moderate',
            'éå¸¸æ”¾é¬†': 'Very Relaxed',
            'åƒè€ƒ': 'Ref',
            // Accumulating data message
            'ç´¯ç©é«˜å“è³ªæ•¸æ“š...': 'Accumulating quality data...',
            // ROI labels
            'é¡é ­': 'Forehead', 'å·¦é °': 'L. Cheek', 'å³é °': 'R. Cheek',
        };

        // Store original zh text from data-i18n elements
        const _i18nOriginals = new Map();

        function applyLang() {
            document.documentElement.setAttribute('data-lang', currentLang);
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const zhKey = el.getAttribute('data-i18n');
                if (!_i18nOriginals.has(el)) _i18nOriginals.set(el, el.textContent);
                const zhText = _i18nOriginals.get(el) || zhKey;
                const enText = I18N[zhKey] || zhKey;
                if (currentLang === 'zh') {
                    el.textContent = zhText;
                } else if (currentLang === 'en') {
                    el.textContent = enText;
                } else { // dual
                    if (zhText !== enText) {
                        el.innerHTML = `${zhText} <span style="opacity:0.55;font-size:0.85em">${enText}</span>`;
                    } else {
                        el.textContent = zhText;
                    }
                }
            });
            // Placeholders
            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                const zhKey = el.getAttribute('data-i18n-placeholder');
                const enText = I18N[zhKey] || zhKey;
                if (currentLang === 'en') el.placeholder = enText;
                else if (currentLang === 'dual') el.placeholder = zhKey + ' / ' + enText;
                else el.placeholder = zhKey;
            });
            localStorage.setItem('rppg-lang', currentLang);
        }

        function toggleLang() {
            const modes = ['dual', 'zh', 'en'];
            currentLang = modes[(modes.indexOf(currentLang) + 1) % modes.length];
            applyLang();
            const labels = { dual: 'ğŸŒ é›™èª', zh: 'ğŸ‡¹ğŸ‡¼ ä¸­æ–‡', en: 'ğŸ‡ºğŸ‡¸ EN' };
            document.getElementById('langBtn').textContent = { dual: 'ğŸŒ', zh: 'ğŸ‡¹ğŸ‡¼', en: 'ğŸ‡ºğŸ‡¸' }[currentLang];
        }

        // Translation helper for dynamic JS strings
        function t(zhText) {
            if (currentLang === 'zh') return zhText;
            const en = I18N[zhText];
            if (!en) return zhText;
            if (currentLang === 'en') return en;
            // dual
            return zhText !== en ? `${zhText} ${en}` : zhText;
        }

        // ===== Multi-ROI =====
        function getMultiROI(face, W, H) {
            const f = face;
            const yaw = f.yaw || 0;
            const YAW_THRESHOLD = 0.20; // ~20% offset = ~25Â° turn
            // Forehead (always visible)
            const fh = { x: f.x + f.w * 0.2, y: f.y - f.h * 0.15, w: f.w * 0.6, h: f.h * 0.18, label: 'é¡é ­', colorIdx: 0 };
            const roisRaw = [fh];
            // Left cheek: hidden when head turned right (yaw < -threshold)
            if (yaw > -YAW_THRESHOLD) {
                roisRaw.push({ x: f.x + f.w * 0.12, y: f.y + f.h * 0.35, w: f.w * 0.22, h: f.h * 0.20, label: 'å·¦é °', colorIdx: 1 });
            }
            // Right cheek: hidden when head turned left (yaw > threshold)
            if (yaw < YAW_THRESHOLD) {
                roisRaw.push({ x: f.x + f.w * 0.66, y: f.y + f.h * 0.35, w: f.w * 0.22, h: f.h * 0.20, label: 'å³é °', colorIdx: 2 });
            }

            return roisRaw.map(r => ({
                x: Math.round(Math.max(0, Math.min(r.x, W - 2))),
                y: Math.round(Math.max(0, Math.min(r.y, H - 2))),
                w: Math.round(Math.min(r.w, W - r.x)),
                h: Math.round(Math.min(r.h, H - r.y)),
                faceX: Math.round(f.x), faceY: Math.round(f.y),
                faceW: Math.round(f.w), faceH: Math.round(f.h)
            })).filter(r => r.w > 5 && r.h > 5);
        }

        // ===== Init =====
        async function init() {
            signalCanvas = document.getElementById('signalCanvas');
            signalCtx = signalCanvas.getContext('2d');
            faceCanvas = document.getElementById('faceCanvas');
            faceCtx = faceCanvas.getContext('2d');
            trendCanvas = document.getElementById('trendCanvas');
            trendCtx = trendCanvas.getContext('2d');
            harmonicCanvas = document.getElementById('harmonicCanvas');
            harmonicCtx = harmonicCanvas.getContext('2d');
            samplingCanvas = document.createElement('canvas');
            samplingCtx = samplingCanvas.getContext('2d', { willReadFrequently: true });
            await initFaceDetector();
            await populateCameras();
            resizeAll(); window.addEventListener('resize', resizeAll);
            drawEmptyChart(signalCanvas, signalCtx, t('ç­‰å¾…è¨Šè™Ÿ...'));
            drawEmptyChart(trendCanvas, trendCtx, t('ç­‰å¾…è¶¨å‹¢æ•¸æ“š...'));
            drawEmptyChart(harmonicCanvas, harmonicCtx, t('ç­‰å¾…è„ˆè¨ºæ•¸æ“š...'));
            applyLang();
        }

        async function populateCameras() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const sel = document.getElementById('camSelect');
                const currentVal = sel.value;
                sel.innerHTML = '<option value="">' + t('é¸æ“‡é¡é ­ï¼ˆé è¨­ï¼‰') + '</option>';
                devices.filter(d => d.kind === 'videoinput').forEach((d, i) => {
                    const opt = document.createElement('option');
                    opt.value = d.deviceId;
                    opt.textContent = d.label || `${t('é¡é ­')} ${i + 1}`;
                    if (d.label && d.label.toLowerCase().includes('iphone')) opt.textContent = 'ğŸ“± ' + d.label;
                    sel.appendChild(opt);
                });
                if (currentVal) sel.value = currentVal;
            } catch (e) { console.warn('Cannot enumerate cameras', e); }
        }

        function resizeAll() {
            [signalCanvas, trendCanvas, harmonicCanvas].forEach(c => {
                const r = c.parentElement.getBoundingClientRect();
                c.width = r.width * devicePixelRatio; c.height = r.height * devicePixelRatio;
                c.getContext('2d').scale(devicePixelRatio, devicePixelRatio);
                c.style.width = r.width + 'px'; c.style.height = r.height + 'px';
            });
            const vr = document.getElementById('videoWrap').getBoundingClientRect();
            faceCanvas.width = vr.width; faceCanvas.height = vr.height;
        }

        // ===== MediaPipe =====
        async function initFaceDetector() {
            try {
                mpFace = new FaceDetection({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/${f}` });
                mpFace.setOptions({ model: 'short', minDetectionConfidence: 0.5 });
                mpFace.onResults((res) => {
                    allFaceBoxes = [];
                    if (res.detections) {
                        res.detections.forEach(d => {
                            const bb = d.boundingBox;
                            const vw = samplingCanvas.width, vh = samplingCanvas.height;
                            // Compute head tilt angle from ear tragion keypoints (wider baseline = more accurate)
                            let angle = 0;
                            let yaw = 0; // head left-right rotation
                            if (d.landmarks && d.landmarks.length >= 6) {
                                const leftEar = d.landmarks[4];
                                const rightEar = d.landmarks[5];
                                angle = Math.atan2(
                                    (rightEar.y - leftEar.y) * vh,
                                    (rightEar.x - leftEar.x) * vw
                                );
                                // Estimate yaw from nose position relative to face center
                                if (d.landmarks.length >= 3) {
                                    const nose = d.landmarks[2];
                                    const noseFaceX = (nose.x - bb.xCenter + bb.width / 2) / bb.width; // 0-1 within face
                                    yaw = (noseFaceX - 0.5) * 2; // -1 (turned right) to +1 (turned left)
                                }
                            }
                            allFaceBoxes.push({
                                x: bb.xCenter * vw - (bb.width * vw) / 2,
                                y: bb.yCenter * vh - (bb.height * vh) / 2,
                                w: bb.width * vw, h: bb.height * vh,
                                cx: bb.xCenter * vw, cy: bb.yCenter * vh,
                                angle: angle,
                                yaw: yaw
                            });
                        });
                    }
                    lastFaceBox = allFaceBoxes.length > 0 ? allFaceBoxes[0] : null;
                    // Update person count
                    const badge = document.getElementById('personBadge');
                    if (allFaceBoxes.length > 0) {
                        badge.style.display = 'inline-flex';
                        document.getElementById('personCount').textContent = allFaceBoxes.length;
                    } else { badge.style.display = 'none'; }
                });
                const tmp = document.createElement('canvas'); tmp.width = 10; tmp.height = 10;
                await mpFace.send({ image: tmp });
                hasFaceAPI = true;
                console.log('âœ… MediaPipe ready');
            } catch (e) { console.warn('MediaPipe failed', e); hasFaceAPI = false; }
        }

        function lerp(a, b, t) { return a + (b - a) * t; }

        function getSmoothed(raw) {
            if (!raw) return null;
            if (!smoothBox) smoothBox = { ...raw };
            smoothBox.x = lerp(smoothBox.x, raw.x, SM);
            smoothBox.y = lerp(smoothBox.y, raw.y, SM);
            smoothBox.w = lerp(smoothBox.w, raw.w, SM);
            smoothBox.h = lerp(smoothBox.h, raw.h, SM);
            smoothBox.cx = lerp(smoothBox.cx || raw.cx, raw.cx, SM);
            smoothBox.cy = lerp(smoothBox.cy || raw.cy, raw.cy, SM);
            smoothBox.angle = lerp(smoothBox.angle || 0, raw.angle || 0, SM);
            smoothBox.yaw = lerp(smoothBox.yaw || 0, raw.yaw || 0, SM);
            return { ...smoothBox };
        }

        // ===== Camera =====
        async function startCamera() {
            try {
                const sel = document.getElementById('camSelect');
                const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                const constraints = {
                    video: {
                        width: { ideal: isMobile ? 320 : 640 },
                        height: { ideal: isMobile ? 240 : 480 },
                        frameRate: { ideal: isMobile ? 20 : 30 }
                    }
                };
                if (sel.value) {
                    constraints.video.deviceId = { exact: sel.value };
                } else {
                    constraints.video.facingMode = 'user';
                }
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                const v = document.getElementById('webcam'); v.srcObject = stream; await v.play();
                samplingCanvas.width = v.videoWidth; samplingCanvas.height = v.videoHeight;
                document.getElementById('vidPlaceholder').style.display = 'none';
                document.getElementById('vidOverlay').style.display = 'flex';
                // Refresh camera list after getting permission
                await populateCameras();
                return true;
            } catch (e) { setStatus('error', t('ç„¡æ³•å­˜å–æ”å½±æ©Ÿ') + ': ' + e.message); return false; }
        }
        function stopCamera() {
            if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
            document.getElementById('webcam').srcObject = null;
            document.getElementById('vidPlaceholder').style.display = 'flex';
            document.getElementById('vidOverlay').style.display = 'none';
        }

        // ===== Sound =====
        function playHeartbeat() {
            if (!soundEnabled || !audioCtx) return;
            const o = audioCtx.createOscillator(), g = audioCtx.createGain();
            o.type = 'sine'; o.frequency.value = 60;
            g.gain.setValueAtTime(0.3, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
            o.connect(g); g.connect(audioCtx.destination);
            o.start(); o.stop(audioCtx.currentTime + 0.15);
        }
        function toggleSound() {
            soundEnabled = !soundEnabled;
            if (soundEnabled && !audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            document.getElementById('soundBtn').textContent = soundEnabled ? 'ğŸ”Š' : 'ğŸ”‡';
        }

        // ===== Theme =====
        function toggleTheme() {
            darkMode = !darkMode;
            document.documentElement.setAttribute('data-theme', darkMode ? 'dark' : 'light');
            document.getElementById('themeBtn').textContent = darkMode ? 'ğŸŒ™' : 'â˜€ï¸';
        }

        // ===== Toggle =====
        async function toggleMonitoring() {
            const btn = document.getElementById('startBtn');
            if (!isRunning) {
                btn.disabled = true; setStatus('calibrating', t('æ­£åœ¨å•Ÿå‹•æ”å½±æ©Ÿ...'));
                if (!await startCamera()) { btn.disabled = false; return; }
                isRunning = true; startTime = Date.now(); frameCount = 0;
                gSig.length = 0; rSig.length = 0; bSig.length = 0; ts.length = 0; hrHist.length = 0; rrIntervals.length = 0;
                allHR = []; allSpO2 = []; allBreath = []; hrTrend = [];
                btn.className = 'btn stop'; btn.textContent = 'â¹ ' + t('åœæ­¢åµæ¸¬'); btn.disabled = false;
                document.getElementById('heartIcon').classList.add('beating');
                document.getElementById('calBar').classList.add('vis');
                durationInterval = setInterval(updateDuration, 1000);
                processFrame();
            } else {
                isRunning = false; if (animFrameId) cancelAnimationFrame(animFrameId);
                stopCamera(); clearInterval(durationInterval);
                btn.className = 'btn start'; btn.textContent = 'ğŸš€ ' + t('é–‹å§‹åµæ¸¬');
                document.getElementById('heartIcon').classList.remove('beating');
                document.getElementById('calBar').classList.remove('vis');
                faceCtx.clearRect(0, 0, faceCanvas.width, faceCanvas.height);
                // Auto-save session to database
                const elapsed = startTime ? Math.round((Date.now() - startTime) / 1000) : 0;
                if (elapsed >= 5 && allHR.length > 0) {
                    const avg = arr => arr.length ? Math.round(arr.reduce((a, b) => a + b) / arr.length) : null;
                    saveSession({
                        duration: elapsed,
                        avgHR: avg(allHR), maxHR: allHR.length ? Math.max(...allHR) : null, minHR: allHR.length ? Math.min(...allHR) : null,
                        avgHRV: dispHRV > 0 ? Math.round(dispHRV) : null,
                        avgSpO2: avg(allSpO2), avgBreath: avg(allBreath),
                        qualityScore: Math.round(dispQual),
                        constitution: window._lastConstitution || '',
                        constitutionEmoji: '',
                        emotion: lastEmo ? lastEmo.state : '',
                        harmonics: window._smoothHarmonics ? Array.from(window._smoothHarmonics) : null
                    }).then(() => { loadHistoryUI(); });
                    setStatus('idle', 'âœ… ' + t('åµæ¸¬å·²åœæ­¢ï¼Œè¨˜éŒ„å·²å„²å­˜'));
                } else {
                    setStatus('idle', t('åµæ¸¬å·²åœæ­¢ï¼ˆå¤ªçŸ­æœªå„²å­˜ï¼‰'));
                }
            }
        }

        let mpSendCount = 0; // independent counter for MediaPipe sends (always increments)
        function processFrame() {
            if (!isRunning) return;
            const video = document.getElementById('webcam');
            if (video.readyState < 2) { animFrameId = requestAnimationFrame(processFrame); return; }

            samplingCtx.drawImage(video, 0, 0, samplingCanvas.width, samplingCanvas.height);
            const W = samplingCanvas.width, H = samplingCanvas.height;

            mpSendCount++;
            if (hasFaceAPI && mpFace && mpSendCount % 3 === 0) mpFace.send({ image: video }).catch(() => { });

            const smoothed = lastFaceBox ? getSmoothed(lastFaceBox) : null;

            if (smoothed && smoothed.w > 10 && smoothed.h > 10) {
                const rois = getMultiROI(smoothed, W, H);
                drawOverlay(smoothed, rois);

                // Weights adapt based on number of visible ROIs
                // 1 ROI (forehead only) = [1.0]
                // 2 ROIs (forehead + 1 cheek) = [0.7, 0.3]
                // 3 ROIs (forehead + 2 cheeks) = [0.6, 0.2, 0.2]
                const weights = rois.length === 1 ? [1.0] :
                    rois.length === 2 ? [0.7, 0.3] : [0.6, 0.2, 0.2];
                let rAvg = 0, gAvg = 0, bAvg = 0, totalW = 0;
                rois.forEach((roi, idx) => {
                    const w = weights[idx] || 0.2;
                    const rgb = extractRGB(roi);
                    rAvg += rgb.r * w; gAvg += rgb.g * w; bAvg += rgb.b * w; totalW += w;
                });
                if (totalW > 0) { rAvg /= totalW; gAvg /= totalW; bAvg /= totalW; }

                rSig.push(rAvg); gSig.push(gAvg); bSig.push(bAvg); ts.push(performance.now());
                while (gSig.length > BUF) { gSig.shift(); rSig.shift(); bSig.shift(); ts.shift(); }

                frameCount++;
                const prog = Math.min(100, (frameCount / 150) * 100);
                document.getElementById('calFill').style.width = prog + '%';

                if (frameCount < 90) {
                    setStatus('calibrating', t('æ ¡æº–ä¸­...') + ` ${Math.round(prog)}%`);
                } else {
                    document.getElementById('calBar').classList.remove('vis');
                    if (frameCount % 10 === 0) runAnalysis();
                    setStatus('active', t('ğŸ¯ å¤šå€åŸŸ ROI è¿½è¹¤ä¸­'));
                }
                drawSignal();
            } else {
                faceCtx.clearRect(0, 0, faceCanvas.width, faceCanvas.height);
                smoothBox = null; // reset so box snaps to new position on return
                setStatus('calibrating', t('æœªåµæ¸¬åˆ°è‡‰éƒ¨ï¼Œè«‹é¢å°é¡é ­'));
            }
            animFrameId = requestAnimationFrame(processFrame);
        }

        function extractRGB(roi) {
            const d = samplingCtx.getImageData(roi.x, roi.y, roi.w, roi.h).data;
            let r = 0, g = 0, b = 0, c = 0;
            for (let i = 0; i < d.length; i += 4) { r += d[i]; g += d[i + 1]; b += d[i + 2]; c++; }
            return { r: r / c, g: g / c, b: b / c };
        }

        // ===== Smoothed display state =====
        let dispHR = 0, dispHRV = 0, dispQual = 0, dispSpO2 = 0, dispBreath = 0;
        let dispRMSSD = 0, dispPNN50 = 0, dispLFHF = 0, dispMeanRR = 0;
        let lastEmo = null;
        const EMA = 0.15; // low = smoother (0-1)
        function ema(prev, cur, alpha) { return prev === 0 ? cur : prev + alpha * (cur - prev); }

        // ===== Analysis =====
        let motionWarning = false;
        function runAnalysis() {
            if (gSig.length < 90) return;
            const fps = estimateFPS(ts);

            // Motion artifact detection â€” skip if moving too much
            if (detectMotionArtifact(rSig, gSig, bSig, 10)) {
                motionWarning = true;
                setStatus('calibrating', t('âš ï¸ åµæ¸¬åˆ°ç§»å‹•ï¼Œè«‹ä¿æŒéœæ­¢'));
                return;
            }
            motionWarning = false;

            // Fused POS+CHROM with ambient light compensation
            const fused = fusedHeartRate(rSig, gSig, bSig, fps);
            const hr = fused.hr;
            const filtered = fused.filtered;
            const quality = fused.quality;

            // Signal quality gating â€” reject bad frames
            if (!quality.usable) {
                setStatus('calibrating', t('ğŸ“¡ è¨Šè™Ÿå“è³ªä¸è¶³ï¼Œè«‹èª¿æ•´å…‰ç·šæˆ–å§¿å‹¢'));
                return;
            }

            if (hr > 40 && hr < 200) {
                // Signal quality always displayed
                dispQual = ema(dispQual, quality.score, EMA);
                document.getElementById('qualVal').textContent = Math.round(dispQual);

                // --- Quality Gate: only update metrics when signal is trustworthy ---
                if (!window._goodFrames) window._goodFrames = 0;
                const QUALITY_THRESHOLD = parseInt(document.getElementById('qualThreshold').value) || 70;
                const MIN_GOOD_FRAMES = 5;

                if (quality.score >= QUALITY_THRESHOLD) {
                    window._goodFrames++;

                    // HR (IQR + EMA smoothed)
                    hrHist.push(hr); if (hrHist.length > 30) hrHist.shift();
                    const cleanedHR = rejectOutliersIQR(hrHist);
                    const avgHR = cleanedHR.length > 0 ? cleanedHR.reduce((a, b) => a + b) / cleanedHR.length : hr;
                    dispHR = ema(dispHR, avgHR, EMA);
                    const showHR = Math.round(dispHR);

                    if (window._goodFrames >= MIN_GOOD_FRAMES) {
                        document.getElementById('hrVal').textContent = showHR;
                        document.getElementById('heartIcon').style.animationDuration = (60 / showHR) + 's';
                    }

                    allHR.push(showHR);
                    hrTrend.push({ t: Date.now(), hr: showHR });
                    if (hrTrend.length > 120) hrTrend.shift();
                    playHeartbeat();
                    updateStats();
                    drawTrend();

                    // R-R intervals from peaks
                    const peaks = findPeaksAdaptive(filtered, fps);
                    const rr = [];
                    for (let i = 1; i < peaks.length; i++) {
                        const interval = ((peaks[i] - peaks[i - 1]) / fps) * 1000;
                        if (interval > 300 && interval < 2000) rr.push(interval);
                    }

                    if (rr.length >= 3) {
                        const cleanedRR = rejectOutliersIQR(rr);
                        const hrv = calculateHRVMetrics(cleanedRR.length >= 3 ? cleanedRR : rr);
                        if (hrv && window._goodFrames >= MIN_GOOD_FRAMES) {
                            dispHRV = ema(dispHRV, hrv.sdnn, EMA);
                            dispRMSSD = ema(dispRMSSD, hrv.rmssd, EMA);
                            dispPNN50 = ema(dispPNN50, hrv.pnn50, EMA);
                            dispLFHF = ema(dispLFHF, hrv.lfHfRatio, EMA);
                            dispMeanRR = ema(dispMeanRR, hrv.meanRR, EMA);
                            document.getElementById('hrvVal').textContent = Math.round(dispHRV);
                            document.getElementById('rmssdVal').textContent = Math.round(dispRMSSD);
                            document.getElementById('pnn50Val').textContent = (Math.round(dispPNN50 * 10) / 10) + '%';
                            document.getElementById('lfhfVal').textContent = Math.round(dispLFHF * 100) / 100;
                            document.getElementById('meanRRVal').textContent = Math.round(dispMeanRR) + 'ms';

                            if (!lastEmo || frameCount % 50 === 0) {
                                const emo = analyzeEmotionalState({ sdnn: Math.round(dispHRV), rmssd: Math.round(dispRMSSD), pnn50: Math.round(dispPNN50 * 10) / 10, lfHfRatio: Math.round(dispLFHF * 100) / 100 }, showHR);
                                lastEmo = emo;
                                document.getElementById('emotionVal').textContent = emo.emoji;
                                document.getElementById('emotionLabel').textContent = emo.state;
                                document.getElementById('emotionVal').style.color = emo.color;
                            }
                        }
                    }

                    // SpO2 (quality-gated + smoothed)
                    if (window._goodFrames >= MIN_GOOD_FRAMES) {
                        const spo2 = estimateSpO2(rSig, bSig);
                        if (spo2) { dispSpO2 = ema(dispSpO2, spo2, EMA); document.getElementById('spo2Val').textContent = Math.round(dispSpO2); allSpO2.push(Math.round(dispSpO2)); }
                    }

                    // Breathing rate (quality-gated + smoothed)
                    if (window._goodFrames >= MIN_GOOD_FRAMES) {
                        const breath = estimateBreathingRate(filtered, fps);
                        if (breath) { dispBreath = ema(dispBreath, breath, EMA); document.getElementById('breathVal').textContent = Math.round(dispBreath); allBreath.push(Math.round(dispBreath)); }
                    }

                    // Stress detection update (every 10 frames)
                    if (frameCount % 10 === 0 && stressMode) {
                        updateStressDetection(dispHR, dispHRV, dispBreath);
                    }

                    // Pulse Harmonic Analysis (è„ˆè¨º) â€” quality-gated + accumulated smoothing
                    if (frameCount % 50 === 0 && quality.score >= 40) {
                        const harmonicData = pulseHarmonicAnalysis(filtered, fps);
                        if (harmonicData) {
                            if (!window._harmonicSamples) window._harmonicSamples = 0;
                            window._harmonicSamples++;
                            if (!window._smoothHarmonics) window._smoothHarmonics = new Array(11).fill(0);
                            const alpha = window._harmonicSamples < 3 ? 0.5 : 0.08;
                            harmonicData.harmonics.forEach((h, i) => {
                                window._smoothHarmonics[i] = window._smoothHarmonics[i] === 0
                                    ? h.percentage : ema(window._smoothHarmonics[i], h.percentage, alpha);
                                h.percentage = window._smoothHarmonics[i];
                            });
                            if (window._harmonicSamples >= 3) {
                                if (!window._lastConstitution || window._lastConstitution !== harmonicData.constitution) window._lastConstitution = harmonicData.constitution;
                                harmonicData.constitution = window._lastConstitution;
                                drawHarmonics(harmonicData);
                            } else {
                                drawEmptyChart(harmonicCanvas, harmonicCtx, t('ç´¯ç©é«˜å“è³ªæ•¸æ“š...') + ` (${window._harmonicSamples}/3)`);
                            }
                        }
                    }

                    if (window._goodFrames < MIN_GOOD_FRAMES) {
                        setStatus('calibrating', `ğŸ“Š ç´¯ç©å¯ä¿¡æ•¸æ“šä¸­... (${window._goodFrames}/${MIN_GOOD_FRAMES})`);
                    } else {
                        setStatus('active', `ğŸ¯ POS+CHROM èåˆè¿½è¹¤ Â· SNR ${quality.snr}dB Â· å“è³ª ${Math.round(quality.score)}%`);
                    }
                } else {
                    // Quality too low â€” freeze all metrics at last known good values
                    setStatus('calibrating', `â³ è¨Šè™Ÿå“è³ªåä½ (${Math.round(quality.score)}%)ï¼Œæ•¸æ“šæš«åœæ›´æ–°...`);
                }
            }
        }

        function calcQuality(sig, fps) {
            if (sig.length < 30) return 0;
            const mean = sig.reduce((a, b) => a + b) / sig.length;
            const std = Math.sqrt(sig.reduce((s, v) => s + (v - mean) ** 2, 0) / sig.length);
            let q = 0;
            if (std > 0.005 && std < 10) q = Math.min(80, std * 150);
            const peaks = findPeaksAdaptive(sig.slice(-90), fps);
            if (peaks.length >= 2 && peaks.length <= 12) q = Math.min(99, q + 20);
            return q;
        }

        // ===== Drawing =====
        function drawOverlay(face, rois) {
            faceCtx.clearRect(0, 0, faceCanvas.width, faceCanvas.height);
            const sx = faceCanvas.width / samplingCanvas.width, sy = faceCanvas.height / samplingCanvas.height;
            const angle = face.angle || 0;
            const fcx = (face.cx || (face.x + face.w / 2)) * sx;
            const fcy = (face.cy || (face.y + face.h / 2)) * sy;

            // Rotate all overlays around face center
            faceCtx.save();
            faceCtx.translate(fcx, fcy);
            faceCtx.rotate(angle);

            // Face box
            faceCtx.strokeStyle = 'rgba(88,86,214,0.5)'; faceCtx.lineWidth = 2; faceCtx.setLineDash([6, 3]);
            faceCtx.strokeRect(-face.w * sx / 2, -face.h * sy / 2, face.w * sx, face.h * sy);

            // ROIs (relative to face center)
            const colors = ['rgba(48,209,88,0.8)', 'rgba(90,200,250,0.8)', 'rgba(255,159,10,0.8)'];
            faceCtx.setLineDash([]);
            rois.forEach((r) => {
                const color = colors[r.colorIdx || 0];
                const rx = (r.x - (face.cx || (face.x + face.w / 2))) * sx;
                const ry = (r.y - (face.cy || (face.y + face.h / 2))) * sy;
                faceCtx.strokeStyle = color; faceCtx.lineWidth = 2;
                faceCtx.strokeRect(rx, ry, r.w * sx, r.h * sy);
                faceCtx.fillStyle = color.replace('0.8', '0.1');
                faceCtx.fillRect(rx, ry, r.w * sx, r.h * sy);
                faceCtx.font = '10px Inter'; faceCtx.fillStyle = color;
                faceCtx.fillText(t(r.label || ''), rx, ry - 3);
            });
            faceCtx.restore();

            // Other faces (no rotation)
            allFaceBoxes.slice(1).forEach(f => {
                faceCtx.strokeStyle = 'rgba(255,45,85,0.4)'; faceCtx.lineWidth = 1; faceCtx.setLineDash([4, 4]);
                faceCtx.strokeRect(f.x * sx, f.y * sy, f.w * sx, f.h * sy);
            });
        }

        function drawEmptyChart(canvas, ctx, text) {
            const w = canvas.width / devicePixelRatio, h = canvas.height / devicePixelRatio;
            ctx.clearRect(0, 0, w, h);
            ctx.fillStyle = 'rgba(26,26,46,0.5)'; ctx.fillRect(0, 0, w, h);
            ctx.font = '12px Inter'; ctx.fillStyle = 'rgba(255,255,255,0.12)'; ctx.textAlign = 'center';
            ctx.fillText(text, w / 2, h / 2);
        }

        function drawSignal() {
            if (gSig.length < 2) return;
            const w = signalCanvas.width / devicePixelRatio, h = signalCanvas.height / devicePixelRatio;
            signalCtx.clearRect(0, 0, w, h);

            const bg = signalCtx.createLinearGradient(0, 0, 0, h);
            bg.addColorStop(0, 'rgba(26,26,46,0.4)'); bg.addColorStop(1, 'rgba(18,18,26,0.4)');
            signalCtx.fillStyle = bg; signalCtx.fillRect(0, 0, w, h);

            // Grid
            signalCtx.strokeStyle = 'rgba(255,255,255,0.03)'; signalCtx.lineWidth = 1;
            for (let i = 1; i < 5; i++) { const y = h / 5 * i; signalCtx.beginPath(); signalCtx.moveTo(0, y); signalCtx.lineTo(w, y); signalCtx.stroke(); }

            // Use CHROM signal if enough data
            let display;
            if (gSig.length > 30) {
                const fps = estimateFPS(ts);
                const compensated = compensateAmbientLight(rSig, gSig, bSig);
                const posSig = posAlgorithm(compensated.r, compensated.g, compensated.b, fps);
                display = detrendSignal(posSig, 30);
            } else {
                display = detrendSignal(gSig, 30);
            }
            const max = Math.max(...display.map(Math.abs)) || 1;
            const pad = 15;

            // Signal line
            signalCtx.beginPath(); signalCtx.strokeStyle = 'rgba(255,45,85,0.8)'; signalCtx.lineWidth = 1.5; signalCtx.lineJoin = 'round';
            for (let i = 0; i < display.length; i++) {
                const x = (i / (BUF - 1)) * w, y = h / 2 - display[i] / max * (h / 2 - pad);
                i === 0 ? signalCtx.moveTo(x, y) : signalCtx.lineTo(x, y);
            }
            signalCtx.stroke();

            // Glow
            signalCtx.beginPath(); signalCtx.strokeStyle = 'rgba(255,45,85,0.12)'; signalCtx.lineWidth = 6; signalCtx.lineJoin = 'round';
            for (let i = 0; i < display.length; i++) {
                const x = (i / (BUF - 1)) * w, y = h / 2 - display[i] / max * (h / 2 - pad);
                i === 0 ? signalCtx.moveTo(x, y) : signalCtx.lineTo(x, y);
            }
            signalCtx.stroke();
        }

        function drawTrend() {
            if (hrTrend.length < 2) return;
            const w = trendCanvas.width / devicePixelRatio, h = trendCanvas.height / devicePixelRatio;
            trendCtx.clearRect(0, 0, w, h);

            const bg = trendCtx.createLinearGradient(0, 0, 0, h);
            bg.addColorStop(0, 'rgba(26,26,46,0.4)'); bg.addColorStop(1, 'rgba(18,18,26,0.4)');
            trendCtx.fillStyle = bg; trendCtx.fillRect(0, 0, w, h);

            const hrs = hrTrend.map(t => t.hr);
            const min = Math.min(...hrs) - 5, max = Math.max(...hrs) + 5;
            const range = max - min || 1;
            const pad = 12;

            // Fill area
            trendCtx.beginPath();
            hrTrend.forEach((p, i) => {
                const x = (i / (hrTrend.length - 1)) * w;
                const y = pad + (1 - (p.hr - min) / range) * (h - 2 * pad);
                i === 0 ? trendCtx.moveTo(x, y) : trendCtx.lineTo(x, y);
            });
            trendCtx.lineTo(w, h); trendCtx.lineTo(0, h); trendCtx.closePath();
            const fg = trendCtx.createLinearGradient(0, 0, 0, h);
            fg.addColorStop(0, 'rgba(255,45,85,0.15)'); fg.addColorStop(1, 'rgba(255,45,85,0)');
            trendCtx.fillStyle = fg; trendCtx.fill();

            // Line
            trendCtx.beginPath(); trendCtx.strokeStyle = 'rgba(255,45,85,0.7)'; trendCtx.lineWidth = 1.5; trendCtx.lineJoin = 'round';
            hrTrend.forEach((p, i) => {
                const x = (i / (hrTrend.length - 1)) * w;
                const y = pad + (1 - (p.hr - min) / range) * (h - 2 * pad);
                i === 0 ? trendCtx.moveTo(x, y) : trendCtx.lineTo(x, y);
            });
            trendCtx.stroke();

            // Labels
            trendCtx.font = '10px JetBrains Mono'; trendCtx.fillStyle = 'rgba(255,255,255,0.3)'; trendCtx.textAlign = 'right';
            trendCtx.fillText(Math.round(max) + ' BPM', w - 4, pad + 8);
            trendCtx.fillText(Math.round(min) + ' BPM', w - 4, h - 4);
        }

        // ===== Harmonic Bar Chart =====
        function drawHarmonics(data) {
            if (!data || !data.harmonics) return;
            const w = harmonicCanvas.width / devicePixelRatio, h = harmonicCanvas.height / devicePixelRatio;
            harmonicCtx.clearRect(0, 0, w, h);

            const bg = harmonicCtx.createLinearGradient(0, 0, 0, h);
            bg.addColorStop(0, 'rgba(26,26,46,0.4)'); bg.addColorStop(1, 'rgba(18,18,26,0.4)');
            harmonicCtx.fillStyle = bg; harmonicCtx.fillRect(0, 0, w, h);

            const bars = data.harmonics;
            const maxPct = Math.max(...bars.map(b => b.percentage), 1);
            const barCount = bars.length;
            const gap = 4;
            const barW = (w - 40 - gap * (barCount + 1)) / barCount;
            const padTop = 14, padBot = 28;

            bars.forEach((b, i) => {
                const x = 20 + gap + i * (barW + gap);
                const barH = ((b.percentage / maxPct) * (h - padTop - padBot));
                const y = h - padBot - barH;

                // Bar with gradient
                const grad = harmonicCtx.createLinearGradient(x, y, x, h - padBot);
                grad.addColorStop(0, b.color); grad.addColorStop(1, b.color + '44');
                harmonicCtx.fillStyle = grad;
                harmonicCtx.beginPath();
                harmonicCtx.roundRect(x, y, barW, barH, [3, 3, 0, 0]);
                harmonicCtx.fill();

                // Percentage label
                harmonicCtx.font = '9px JetBrains Mono';
                harmonicCtx.fillStyle = 'rgba(255,255,255,0.8)';
                harmonicCtx.textAlign = 'center';
                harmonicCtx.fillText(Math.round(b.percentage) + '%', x + barW / 2, y - 3);

                // Organ name
                harmonicCtx.font = '9px Inter';
                harmonicCtx.fillStyle = 'rgba(255,255,255,0.5)';
                harmonicCtx.fillText(t(b.name), x + barW / 2, h - padBot + 12);

                // Harmonic label
                harmonicCtx.font = '7px JetBrains Mono';
                harmonicCtx.fillStyle = 'rgba(255,255,255,0.25)';
                harmonicCtx.fillText('C' + b.harmonic, x + barW / 2, h - padBot + 22);
            });

            // Update detail grid
            const detail = document.getElementById('harmonicDetail');
            detail.innerHTML = bars.slice(0, 7).map(b =>
                `<div style="text-align:center;padding:4px;background:${b.color}15;border-radius:6px;border:1px solid ${b.color}33">
                    <div>${b.emoji} ${t(b.name)}</div>
                    <div style="font-weight:700;color:${b.color}">${Math.round(b.percentage)}%</div>
                    <div style="color:${b.statusColor};font-size:0.55rem">${t(b.status)}</div>
                    <div style="color:rgba(255,255,255,0.3);font-size:0.5rem">${t('åƒè€ƒ')} ${b.expectedRange || ''}</div>
                </div>`
            ).join('');

            // Constitution badge
            document.getElementById('constitutionBadge').textContent = data.constitutionEmoji + ' ' + t(data.constitution);
        }

        // ===== Helpers =====
        function setStatus(type, text) {
            const bar = document.getElementById('statusBar');
            bar.className = 'status-bar ' + (type === 'active' ? 'active' : type === 'calibrating' ? 'calibrating' : '');
            document.getElementById('statusText').textContent = text;
        }
        function updateDuration() {
            if (!startTime) return;
            const s = Math.floor((Date.now() - startTime) / 1000);
            document.getElementById('duration').textContent = String(Math.floor(s / 60)).padStart(2, '0') + ':' + String(s % 60).padStart(2, '0');
        }
        function updateStats() {
            if (!allHR.length) return;
            const avg = Math.round(allHR.reduce((a, b) => a + b) / allHR.length);
            document.getElementById('avgHR').textContent = avg + ' BPM';
            document.getElementById('maxHR').textContent = Math.max(...allHR) + ' BPM';
            document.getElementById('minHR').textContent = Math.min(...allHR) + ' BPM';
            if (allSpO2.length) document.getElementById('avgSpO2').textContent = Math.round(allSpO2.reduce((a, b) => a + b) / allSpO2.length) + '%';
            if (allBreath.length) document.getElementById('avgBreath').textContent = Math.round(allBreath.reduce((a, b) => a + b) / allBreath.length) + ' ' + t('æ¬¡/åˆ†');
        }

        // ===== Export =====
        function exportReport() {
            if (!allHR.length) { alert(t('è«‹å…ˆæ¸¬é‡æ•¸æ“šå†åŒ¯å‡ºå ±å‘Š')); return; }
            const now = new Date();
            const elapsed = startTime ? Math.floor((Date.now() - startTime) / 1000) : 0;
            const avgHR = Math.round(allHR.reduce((a, b) => a + b) / allHR.length);
            const avgSp = allSpO2.length ? Math.round(allSpO2.reduce((a, b) => a + b) / allSpO2.length) : 'N/A';
            const avgBr = allBreath.length ? Math.round(allBreath.reduce((a, b) => a + b) / allBreath.length) : 'N/A';

            const report = `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ğŸ’“ rPPG Pro å¿ƒç‡ç›£æ¸¬å ±å‘Š
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“… æ—¥æœŸ: ${now.toLocaleDateString('zh-TW')} ${now.toLocaleTimeString('zh-TW')}
â±ï¸ æ¸¬é‡æ™‚é•·: ${Math.floor(elapsed / 60)}åˆ†${elapsed % 60}ç§’

â”â”â”â” åŸºæœ¬æ•¸æ“š â”â”â”â”
â¤ï¸ å¹³å‡å¿ƒç‡: ${avgHR} BPM
ğŸ“ˆ æœ€é«˜å¿ƒç‡: ${Math.max(...allHR)} BPM
ğŸ“‰ æœ€ä½å¿ƒç‡: ${Math.min(...allHR)} BPM
ğŸ©¸ å¹³å‡è¡€æ°§: ${avgSp}%
ğŸ« å¹³å‡å‘¼å¸ç‡: ${avgBr} æ¬¡/åˆ†

â”â”â”â” HRV è©³ç´° â”â”â”â”
SDNN: ${document.getElementById('hrvVal').textContent} ms
RMSSD: ${document.getElementById('rmssdVal').textContent} ms
pNN50: ${document.getElementById('pnn50Val').textContent}
LF/HF: ${document.getElementById('lfhfVal').textContent}

â”â”â”â” æƒ…ç·’åˆ†æ â”â”â”â”
${document.getElementById('emotionVal').textContent} ${document.getElementById('emotionLabel').textContent}

â”â”â”â” å¿ƒç‡è¶¨å‹¢ â”â”â”â”
${hrTrend.slice(-20).map(t => {
                const d = new Date(t.t);
                return d.toLocaleTimeString('zh-TW') + ' â†’ ' + t.hr + ' BPM';
            }).join('\n')}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
âš ï¸ æ­¤å ±å‘ŠåŸºæ–¼å½±åƒåˆ†æä¼°ç®—ï¼Œåƒ…ä¾›åƒè€ƒï¼Œä¸å¯ä½œç‚ºé†«ç™‚è¨ºæ–·ä¾æ“šã€‚
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`;
            const blob = new Blob([report], { type: 'text/plain;charset=utf-8' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `rPPG_Report_${now.toISOString().slice(0, 10)}.txt`;
            a.click(); URL.revokeObjectURL(a.href);
        }

        // ===== Section Reorder =====
        function moveSection(btn, direction) {
            const section = btn.closest('.sortable-section');
            const container = section.parentElement;
            const sections = Array.from(container.querySelectorAll('.sortable-section'));
            const idx = sections.indexOf(section);

            if (direction === -1 && idx > 0) {
                container.insertBefore(section, sections[idx - 1]);
            } else if (direction === 1 && idx < sections.length - 1) {
                container.insertBefore(sections[idx + 1], section);
            }

            // Flash animation
            section.style.transition = 'transform 0.15s';
            section.style.transform = 'scale(1.01)';
            setTimeout(() => { section.style.transform = ''; }, 200);

            saveSectionOrder();
        }

        function saveSectionOrder() {
            const container = document.getElementById('sortableContainer');
            if (!container) return;
            const order = Array.from(container.querySelectorAll('.sortable-section'))
                .map(s => s.dataset.section);
            localStorage.setItem('rppg_section_order', JSON.stringify(order));
        }

        function applySectionOrder() {
            const saved = localStorage.getItem('rppg_section_order');
            if (!saved) return;
            try {
                const order = JSON.parse(saved);
                const container = document.getElementById('sortableContainer');
                if (!container) return;
                order.forEach(id => {
                    const section = container.querySelector(`[data-section="${id}"]`);
                    if (section) container.appendChild(section);
                });
            } catch (e) { }
        }

        // ===== Stress Detection Engine =====
        let stressMode = false;
        let stressPhaseState = 'idle'; // idle, baseline, active
        let stressBaseline = { hr: [], hrv: [], breath: [] };
        let stressBaselineAvg = { hr: 0, hrv: 0, breath: 0 };
        let stressStartTime = 0;
        const BASELINE_DURATION = 30; // seconds

        function toggleStressMode() {
            if (!isRunning) {
                alert(t('è«‹å…ˆå•Ÿå‹•æ”å½±æ©Ÿåµæ¸¬ï¼'));
                return;
            }
            const btn = document.getElementById('stressBtn');
            const panel = document.getElementById('stressPanel');

            if (stressMode) {
                // Stop stress mode
                stressMode = false;
                stressPhaseState = 'idle';
                btn.innerHTML = 'â–¶ï¸ ' + t('å•Ÿå‹•');
                btn.style.background = 'rgba(255,149,0,0.2)';
                btn.style.color = '#ff9500';
                panel.style.display = 'none';
            } else {
                // Start baseline recording
                stressMode = true;
                stressPhaseState = 'baseline';
                stressBaseline = { hr: [], hrv: [], breath: [] };
                stressStartTime = Date.now();
                btn.innerHTML = 'â¹ ' + t('åœæ­¢');
                btn.style.background = 'rgba(255,45,85,0.2)';
                btn.style.color = '#ff2d55';
                panel.style.display = 'block';
                document.getElementById('stressProgress').style.display = 'block';
                document.getElementById('stressVerdict').style.display = 'none';
                document.getElementById('stressPhase').innerHTML = 'ğŸ“ <b>Phase 1ï¼š' + t('è«‹ä¿æŒæ”¾é¬†ï¼Œæ­£å¸¸å‘¼å¸ 30 ç§’...') + '</b>';
                document.getElementById('stressScore').textContent = '0';
                document.getElementById('stressGauge').style.width = '0%';
                document.getElementById('stressHR').textContent = '--';
                document.getElementById('stressHRV').textContent = '--';
                document.getElementById('stressBreath').textContent = '--';
            }
        }

        function updateStressDetection(currentHR, currentHRV, currentBreath) {
            if (!stressMode) return;

            const elapsed = (Date.now() - stressStartTime) / 1000;

            if (stressPhaseState === 'baseline') {
                // Collecting baseline data
                if (currentHR > 0) stressBaseline.hr.push(currentHR);
                if (currentHRV > 0) stressBaseline.hrv.push(currentHRV);
                if (currentBreath > 0) stressBaseline.breath.push(currentBreath);

                const progress = Math.min(100, (elapsed / BASELINE_DURATION) * 100);
                document.getElementById('stressProgressBar').style.width = progress + '%';

                if (elapsed >= BASELINE_DURATION && stressBaseline.hr.length >= 5) {
                    // Baseline complete â€” calculate averages
                    const avg = arr => arr.length ? arr.reduce((a, b) => a + b) / arr.length : 0;
                    stressBaselineAvg.hr = avg(stressBaseline.hr);
                    stressBaselineAvg.hrv = avg(stressBaseline.hrv);
                    stressBaselineAvg.breath = avg(stressBaseline.breath);

                    stressPhaseState = 'active';
                    document.getElementById('stressProgress').style.display = 'none';
                    document.getElementById('stressPhase').innerHTML = `ğŸ¯ <b>Phase 2</b><br>Baseline â€” HR: ${Math.round(stressBaselineAvg.hr)} Â· HRV: ${Math.round(stressBaselineAvg.hrv)} Â· ${t('å‘¼å¸')}: ${Math.round(stressBaselineAvg.breath)}`;

                    // Vibrate on mobile to signal readiness
                    if (navigator.vibrate) navigator.vibrate(200);
                }
            } else if (stressPhaseState === 'active') {
                // Real-time stress comparison
                const hrChange = stressBaselineAvg.hr > 0
                    ? ((currentHR - stressBaselineAvg.hr) / stressBaselineAvg.hr) * 100 : 0;
                const hrvChange = stressBaselineAvg.hrv > 0
                    ? ((stressBaselineAvg.hrv - currentHRV) / stressBaselineAvg.hrv) * 100 : 0;
                const breathChange = stressBaselineAvg.breath > 0
                    ? ((currentBreath - stressBaselineAvg.breath) / stressBaselineAvg.breath) * 100 : 0;

                // Stress scoring: weighted sum, clamp 0-100
                // HR spike: 40% weight, HRV drop: 35% weight, Breath change: 25% weight
                const hrScore = Math.max(0, Math.min(100, hrChange * 5));      // +20% HR â†’ 100
                const hrvScore = Math.max(0, Math.min(100, hrvChange * 3.3));   // +30% HRV drop â†’ 100
                const breathScore = Math.max(0, Math.min(100, Math.abs(breathChange) * 4)); // Â±25% â†’ 100

                const totalScore = Math.round(hrScore * 0.4 + hrvScore * 0.35 + breathScore * 0.25);
                const clampedScore = Math.max(0, Math.min(100, totalScore));

                // Update UI
                document.getElementById('stressScore').textContent = clampedScore;
                document.getElementById('stressGauge').style.width = clampedScore + '%';

                // Color the score
                const scoreEl = document.getElementById('stressScore');
                if (clampedScore < 30) {
                    scoreEl.style.color = '#34c759';
                } else if (clampedScore < 60) {
                    scoreEl.style.color = '#ff9500';
                } else {
                    scoreEl.style.color = '#ff2d55';
                }

                // Per-indicator display
                const hrSign = hrChange >= 0 ? '+' : '';
                document.getElementById('stressHR').textContent = `${hrSign}${Math.round(hrChange)}%`;
                document.getElementById('stressHR').style.color = hrChange > 10 ? '#ff2d55' : hrChange > 5 ? '#ff9500' : '#34c759';

                const hrvSign = hrvChange >= 0 ? '-' : '+';
                document.getElementById('stressHRV').textContent = `${hrvSign}${Math.abs(Math.round(hrvChange))}%`;
                document.getElementById('stressHRV').style.color = hrvChange > 15 ? '#ff2d55' : hrvChange > 8 ? '#ff9500' : '#34c759';

                document.getElementById('stressBreath').textContent = `${breathChange >= 0 ? '+' : ''}${Math.round(breathChange)}%`;
                document.getElementById('stressBreath').style.color = Math.abs(breathChange) > 20 ? '#ff2d55' : Math.abs(breathChange) > 10 ? '#ff9500' : '#34c759';

                // Verdict
                const verdict = document.getElementById('stressVerdict');
                verdict.style.display = 'block';
                if (clampedScore < 20) {
                    verdict.textContent = t('ğŸ˜Œ éå¸¸æ”¾é¬† â€” æœªåµæ¸¬åˆ°å£“åŠ›åæ‡‰');
                    verdict.style.background = 'rgba(52,199,89,0.12)';
                    verdict.style.color = '#34c759';
                } else if (clampedScore < 40) {
                    verdict.textContent = t('ğŸ™‚ è¼•å¾®æ³¢å‹• â€” æ­£å¸¸ç¯„åœå…§');
                    verdict.style.background = 'rgba(52,199,89,0.08)';
                    verdict.style.color = '#30d158';
                } else if (clampedScore < 60) {
                    verdict.textContent = t('ğŸ˜ ä¸­ç­‰å£“åŠ› â€” åµæ¸¬åˆ°ç”Ÿç†åæ‡‰');
                    verdict.style.background = 'rgba(255,149,0,0.12)';
                    verdict.style.color = '#ff9500';
                } else if (clampedScore < 80) {
                    verdict.textContent = t('ğŸ˜° æ˜é¡¯å£“åŠ› â€” å¤šé …æŒ‡æ¨™ç•°å¸¸');
                    verdict.style.background = 'rgba(255,149,0,0.15)';
                    verdict.style.color = '#ff9500';
                } else {
                    verdict.textContent = t('ğŸš¨ é«˜åº¦ç·Šå¼µ â€” å¼·çƒˆç”Ÿç†å£“åŠ›åæ‡‰');
                    verdict.style.background = 'rgba(255,45,85,0.15)';
                    verdict.style.color = '#ff2d55';
                }
            }
        }

        // ===== History UI =====
        async function loadHistoryUI() {
            const container = document.getElementById('historyTable');
            const sessions = await getSessions(50);
            if (!sessions || sessions.length === 0) {
                container.innerHTML = '<div style="text-align:center;color:var(--text-secondary);padding:20px;font-size:0.75rem">' + t('å°šç„¡è¨˜éŒ„ã€‚é–‹å§‹åµæ¸¬ä¸¦åœæ­¢å¾Œæœƒè‡ªå‹•å„²å­˜ã€‚') + '</div>';
                return;
            }
            let html = `<table style="width:100%;border-collapse:collapse;font-size:0.65rem">
                <thead><tr style="color:var(--text-secondary);border-bottom:1px solid var(--border-color)">
                    <th style="padding:6px;text-align:left">${t('æ—¥æœŸ')}</th>
                    <th style="padding:6px">${t('æ™‚é•·')}</th>
                    <th style="padding:6px">â¤ï¸ HR</th>
                    <th style="padding:6px">ğŸ“Š HRV</th>
                    <th style="padding:6px">ğŸ« SpO2</th>
                    <th style="padding:6px">â˜¯ï¸ ${t('é«”è³ª')}</th>
                    <th style="padding:6px">ğŸ­</th>
                    <th style="padding:6px"></th>
                </tr></thead><tbody>`;
            sessions.forEach(s => {
                const ts = s.timestamp || '';
                const date = ts.slice(0, 10);
                const time = ts.slice(11, 16);
                html += `<tr style="border-bottom:1px solid rgba(255,255,255,0.05)">
                    <td style="padding:5px;white-space:nowrap">${date}<br><span style="color:var(--text-secondary)">${time}</span></td>
                    <td style="padding:5px;text-align:center">${formatDuration(s.duration || 0)}</td>
                    <td style="padding:5px;text-align:center;color:#ff2d55;font-weight:600">${s.avg_hr ? Math.round(s.avg_hr) : '--'}</td>
                    <td style="padding:5px;text-align:center">${s.avg_hrv ? Math.round(s.avg_hrv) : '--'}</td>
                    <td style="padding:5px;text-align:center">${s.avg_spo2 ? Math.round(s.avg_spo2) + '%' : '--'}</td>
                    <td style="padding:5px;text-align:center;font-size:0.6rem">${s.constitution || '--'}</td>
                    <td style="padding:5px;text-align:center">${s.emotion || '--'}</td>
                    <td style="padding:5px;text-align:center">
                        <button onclick="deleteSession('${s.id}').then(()=>loadHistoryUI())"
                            style="background:none;border:none;color:#ff2d55;cursor:pointer;font-size:0.7rem" title="${t('åˆªé™¤')}">âœ•</button>
                    </td>
                </tr>`;
            });
            html += '</tbody></table>';
            container.innerHTML = html;
        }

        // ===== User Management =====
        async function loadUsersUI() {
            const select = document.getElementById('userSelect');
            const users = await getUsers();
            const current = getCurrentUser();
            select.innerHTML = '';
            // Always have default
            if (!users.find(u => u.username === 'default')) {
                select.innerHTML += '<option value="default">' + t('è¨ªå®¢') + '</option>';
            }
            users.forEach(u => {
                const selected = u.username === current ? 'selected' : '';
                const name = u.display_name || u.username;
                select.innerHTML += `<option value="${u.username}" ${selected}>${name}</option>`;
            });
        }

        function switchUser(username) {
            setCurrentUser(username);
            loadHistoryUI();
        }

        function toggleAddUser() {
            const btn = document.getElementById('addUserBtn');
            const input = document.getElementById('addUserInput');
            if (input.style.display === 'flex') {
                input.style.display = 'none';
                btn.style.display = '';
            } else {
                input.style.display = 'flex';
                btn.style.display = 'none';
                document.getElementById('newUserName').value = '';
                document.getElementById('newUserName').focus();
            }
        }

        async function confirmAddUser() {
            const nameInput = document.getElementById('newUserName');
            const name = nameInput.value.trim();
            if (!name) { nameInput.focus(); return; }
            const username = name.toLowerCase().replace(/\s+/g, '_');
            const result = await createUser(username, name);
            if (result) {
                setCurrentUser(username);
                await loadUsersUI();
                loadHistoryUI();
            }
            toggleAddUser();
        }

        // ===== PWA Service Worker =====
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js')
                .then(reg => console.log('âœ… SW registered:', reg.scope))
                .catch(err => console.warn('SW failed:', err));
        }

        window.addEventListener('DOMContentLoaded', init);
        window.addEventListener('DOMContentLoaded', () => {
            applySectionOrder();
            setTimeout(loadUsersUI, 300);
            setTimeout(loadHistoryUI, 500);
            setTimeout(applyLang, 100);
        });
    </script>
</body>

</html>